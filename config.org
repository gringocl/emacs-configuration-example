#+title: Emacs Config
#+startup: overview
#+TODO: DISABLED

* Things to do
** New window placement for magit and vterm
** Mouse over tabs doesn't change
** Snippets
** Imagine a way to keep automated test output in a buffer to utilize as library documentation, ie could be foldable, searchable?
* Utility Functions
** `insert-log-date`

#+begin_src emacs-lisp
(defun  c/insert-log-date ()
    "Insert a date in my typical log format.

e.g. Fri Jan 07 2022"
    (interactive)
    (insert (format-time-string "%a %b %-e %Y")))

(global-set-key (kbd "C-x C-d") 'c/insert-log-date)
#+end_src
** `yank-buffer-path`

#+begin_src emacs-lisp
(defun c/yank-buffer-path (&optional root)
  "Copy the current buffer's path to the kill ring."
  (interactive)
  (if-let* ((filename (or (buffer-file-name (buffer-base-buffer))
                         (bound-and-true-p list-buffers-directory)))
            (path (abbreviate-file-name
                  (if root
                      (file-relative-name filename root)
                    filename))))
      (progn
        (kill-new path)
        (if (string= path (car kill-ring))
            (message "Copied path: %s" path)
          (user-error "Couldn't copy filename in current buffer")))
    (error "Couldn't find filename in current buffer")))
#+end_src

** `yank-buffer-path-relative-to-project`

#+begin_src emacs-lisp
(defun c/yank-buffer-path-relative-to-project (&optional include-root)
  "Copy the current buffer's path to the kill ring.
With non-nil prefix INCLUDE-ROOT, also include the project's root."
  (interactive "P")
  (c/yank-buffer-path
   (if include-root
       (file-name-directory (directory-file-name (project-root (project-current))))
     (project-root (project-current)))))
#+end_src

* Initial Packages
** GCMH

#+begin_src emacs-lisp
(use-package gcmh
  :commands (gcmh-mode))
#+end_src

** Leader Key

#+begin_src emacs-lisp
(use-package leader-key
  :ensure (leader-key :host github :repo "aaronjensen/emacs-leader-key" :protocol ssh :wait t)
  :demand t
  :config
  (leader-key-init)

  (leader-key-declare-prefix "a" "apps" "Applications")
  (leader-key-declare-prefix "b" "buffers" "Buffers")
  (leader-key-declare-prefix "e p" "profiler" "Profiler")
  (leader-key-declare-prefix "e" "emacs" "Emacs")
  (leader-key-declare-prefix "f" "files" "Files")
  (leader-key-declare-prefix "g" "git" "Git")
  (leader-key-declare-prefix "h" "help" "Help")
  (leader-key-declare-prefix "j" "journal" "Journal")
  (leader-key-declare-prefix "l" "layouts" "Layouts")
  (leader-key-declare-prefix "m" "major" "Major Mode")
  (leader-key-declare-prefix "n" "notes" "Notes")
  (leader-key-declare-prefix "o" "org" "Org Mode")
  (leader-key-declare-prefix "p" "projects" "Projects")
  (leader-key-declare-prefix "q" "quit" "Quit Emacs")
  (leader-key-declare-prefix "r" "error" "Error")
  (leader-key-declare-prefix "S" "flyspell" "Flyspell")
  (leader-key-declare-prefix "s" "search" "Search")
  (leader-key-declare-prefix "T" "toggle" "Toggle")
  (leader-key-declare-prefix "u" "C-u" "Universal Argument")
  (leader-key-declare-prefix "w" "windows" "Windows")

  (leader-key-set
   "a g" #'gptel-menu

   ;; Buffer
   "b b" #'consult-buffer
   "b d" #'kill-current-buffer
   "b k" #'kill-current-buffer
   "b B" #'switch-to-buffer
   "b r" #'revert-buffer

   ;; Help
   "h k" #'describe-key
   "h v" #'describe-variable
   "h f" #'describe-function

   ;; Git
   "g g" #'magit-status
   "g B" #'magit-blame-addition

   ;; Files
   "f f" #'project-find-file
   "f F" #'find-file
   "f y" #'c/yank-buffer-path-relative-to-project
   "f Y" #'c/yank-buffer-path

   ;; Primary commands
   "x" #'execute-extended-command
   "X" #'execute-extended-command-for-buffer
   "u" #'universal-argument
   ";" #'evilnc-comment-operator
   "/" #'consult-ripgrep
   "*" #'c/search-project-for-symbol
   "TAB" #'evil-switch-to-windows-last-buffer

   "e l" #'find-library

   "q r" #'restart-emacs
   "q q" #'save-buffers-kill-emacs

   "s u" #'vundo

   ;; Window
   "w v" #'evil-window-vsplit
   "w h" #'evil-window-split

   ;; Toggle
   "T w" #'visual-line-mode))
#+end_src

** Compdef

Add =:capf= and =:compdef= to =use-package=.

#+begin_src emacs-lisp
(use-package compdef
  :ensure (:wait t))
#+end_src

** No Littering

Move all common files typically written to the =user-emacs-directory= to the =var=
and =etc= subdirectories so that they can be included in =.gitignore=

#+begin_src emacs-lisp
(use-package no-littering
  :ensure (:wait t))
#+end_src

** gptel

#+begin_src emacs-lisp
(use-package gptel
  :commands (gptel gptel-menu gptel-send gptel-request)
  :config
  (defun ms/load-anthropic-key ()
    (gptel-api-key-from-auth-source "api.anthropic.com"))

  (gptel-make-anthropic "Claude"
                        :stream t
                        :key #'ms/load-anthropic-key
                        :models '(claude-3-5-sonnet-20241022))

  (setq
   gptel-model "mistral-nemo:12b"
   gptel-backend (gptel-make-ollama "Ollama"
                                    :host "ollama.diffusenebula.org"
                                    :stream t
                                    :models '(mistral-nemo:12b
                                              mistral-nemo:12b-instruct-2407-q6_K))))
#+end_src


#+begin_src emacs-lisp
(use-package whisper
  :ensure (:host github :repo "natrys/whisper.el" :protocol ssh :wait t)
  :bind ("C-H-r" . whisper-run)
  :config
  (setq whisper-install-directory "/tmp/"
        whisper-model "base"
        whisper-language "en"
        whisper-translate nil
        whisper-use-threads (/ (num-processors) 2)))


(defun rk/get-ffmpeg-device ()
  "Gets the list of devices available to ffmpeg.
The output of the ffmpeg command is pretty messy, e.g.
  [AVFoundation indev @ 0x7f867f004580] AVFoundation video devices:
  [AVFoundation indev @ 0x7f867f004580] [0] FaceTime HD Camera (Built-in)
  [AVFoundation indev @ 0x7f867f004580] AVFoundation audio devices:
  [AVFoundation indev @ 0x7f867f004580] [0] Cam Link 4K
  [AVFoundation indev @ 0x7f867f004580] [1] MacBook Pro Microphone
so we need to parse it to get the list of devices.
The return value contains two lists, one for video devices and one for audio devices.
Each list contains a list of cons cells, where the car is the device number and the cdr is the device name."
  (unless (string-equal system-type "darwin")
    (error "This function is currently only supported on macOS"))

  (let ((lines (string-split (shell-command-to-string "ffmpeg -list_devices true -f avfoundation -i dummy || true") "\n")))
    (cl-loop with at-video-devices = nil
             with at-audio-devices = nil
             with video-devices = nil
             with audio-devices = nil
             for line in lines
             when (string-match "AVFoundation video devices:" line)
             do (setq at-video-devices t
                      at-audio-devices nil)
             when (string-match "AVFoundation audio devices:" line)
             do (setq at-audio-devices t
                      at-video-devices nil)
             when (and at-video-devices
                       (string-match "\\[\\([0-9]+\\)\\] \\(.+\\)" line))
             do (push (cons (string-to-number (match-string 1 line)) (match-string 2 line)) video-devices)
             when (and at-audio-devices
                       (string-match "\\[\\([0-9]+\\)\\] \\(.+\\)" line))
             do (push (cons (string-to-number (match-string 1 line)) (match-string 2 line)) audio-devices)
             finally return (list (nreverse video-devices) (nreverse audio-devices)))))

(defun rk/find-device-matching (string type)
  "Get the devices from `rk/get-ffmpeg-device' and look for a device
matching `STRING'. `TYPE' can be :video or :audio."
  (let* ((devices (rk/get-ffmpeg-device))
         (device-list (if (eq type :video)
                          (car devices)
                        (cadr devices))))
    (cl-loop for device in device-list
             when (string-match-p string (cdr device))
             return (car device))))

(defcustom rk/default-audio-device nil
  "The default audio device to use for whisper.el and outher audio processes."
  :type 'string)

(defun rk/select-default-audio-device (&optional device-name)
  "Interactively select an audio device to use for whisper.el and other audio processes.
If `DEVICE-NAME' is provided, it will be used instead of prompting the user."
  (interactive)
  (let* ((audio-devices (cadr (rk/get-ffmpeg-device)))
         (indexes (mapcar #'car audio-devices))
         (names (mapcar #'cdr audio-devices))
         (name (or device-name (completing-read "Select audio device: " names nil t))))
    (setq rk/default-audio-device (rk/find-device-matching name :audio))
    (when (boundp 'whisper--ffmpeg-input-device)
      (setq whisper--ffmpeg-input-device (format ":%s" rk/default-audio-device)))))

#+end_src
* Package Management
** Use Feature Macro

Macro to use to configure built-in features, rather than packages that do not need to be installed

#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "`use-package' with package installation (`ensure') disabled."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))
#+end_src

* Base Settings
** General

#+begin_src emacs-lisp
;; (setq initial-buffer-choice
;;   (lambda () (get-buffer "*Messages*")))
;:(setq initial-buffer-choice "~/code/personal/emacs-configuration-example/config.org")
  (setq create-lock-files nil)
#+end_src

** C-g more helpful

Copied from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/][Prot's config]]

#+begin_src emacs-lisp
(defun c/keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

(define-key global-map (kbd "C-g") #'c/keyboard-quit-dwim)
#+end_src

** Pin Entry

#+begin_src emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+end_src

** Customization Saving

Do not save customizations in =init.el=, instead save them in a temporary file
that will be discarded. As a result, any customizations made in a session will
not be persisted across sessions.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name
                   (format "custom-%d-%d.el" (emacs-pid) (random))
                   temporary-file-directory))
#+end_src

** Minibuffer

Support opening new minibuffers from inside existing minibuffers.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

Do not allow the cursor in the minibuffer prompt.

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))

(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src
** Save History

#+begin_src emacs-lisp
(use-feature savehist
  :config
  (savehist-mode))
#+end_src

** Backup and Auto-Save
   
Put backup files and auto-save files in var directory, rather than alongside the original files.
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backup/"))))
(add-hook 'elpaca-after-init-hook
          (lambda ()
            (setq auto-save-list-file-prefix (no-littering-expand-var-file-name "auto-save/sessions/")
                  auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))))
#+end_src
   When paths are too long, there can be errors when auto-save and backup filenames are generated. This uses a consistent hash, rather than the full path to generate the filenames. This is taken from Doom Emacs.
#+begin_src emacs-lisp
(defun c/make-auto-save-file-name-hashed (fn)
  "Compress the auto-save file name so paths don't get too long."
  (let ((buffer-file-name
         (if (or (null buffer-file-name)
                 (find-file-name-handler buffer-file-name 'make-auto-save-file-name))
             buffer-file-name
           (sha1 buffer-file-name))))
    (funcall fn)))
(advice-add #'make-auto-save-file-name :around #'c/make-auto-save-file-name-hashed)

(defun c/make-backup-file-name-hashed (fn file)
  "A few places use the backup file name so paths don't get too long."
  (let ((alist backup-directory-alist)
        backup-directory)
    (while alist
      (let ((elt (car alist)))
        (if (string-match (car elt) file)
            (setq backup-directory (cdr elt) alist nil)
          (setq alist (cdr alist)))))
    (let ((file (funcall fn file)))
      (if (or (null backup-directory)
              (not (file-name-absolute-p backup-directory)))
          file
        (expand-file-name (sha1 (file-name-nondirectory file))
                          (file-name-directory file))))))
(advice-add #'make-backup-file-name-1 :around #'c/make-backup-file-name-hashed)
#+end_src

* Evil
** Evil

#+begin_src emacs-lisp
(use-package evil
  :demand t
  :init
  (setq evil-want-keybinding nil
        evil-want-integration t
        evil-want-C-u-scroll t
        evil-want-C-d-scroll t
        evil-want-C-h-delete t
        evil-disable-insert-state-bindings t
        evil-respect-visual-line-mode t)

  :bind (:map evil-normal-state-map
              ("-" . dired-jump)
              ("C-h" . 'windmove-left)
              ("C-j" . 'windmove-down)
              ("C-k" . 'windmove-up)
              ("C-l" . 'windmove-right))

  :config
  (evil-mode 1)
  (customize-set-variable 'evil-undo-system 'undo-redo))
#+end_src

** Evil Org

#+begin_src emacs-lisp
(use-package evil-org
  :after org
  :hook (org-mode . evil-org-mode))
#+end_src

** Evil Escape

#+begin_src emacs-lisp
(use-package evil-escape
  :after evil
  :hook (pre-command . evil-escape-mode)
  :init
  (setq evil-escape-key-sequence "jk"
        evil-escape-delay 0.2
        evil-escape-excluded-major-modes '(magit-status-mode treemacs-mode))
  (evil-define-key* '(insert replace visual operator) 'global "\C-g" #'evil-escape))
#+end_src

** Evil Collection

#+begin_src emacs-lisp
  (use-package evil-collection
    :after (evil dired magit)
    :init
    (defvar evil-collection-magit-use-z-for-folds t)

    :config
    (evil-collection-init))
#+end_src

** Evil Nerd Comment

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :commands (evilnc-comment-operator)
  :bind (
   ([remap comment-line] . #'evilnc-comment-or-uncomment-lines)))
#+end_src
* User Interface
** DISABLED General UX

Copied this from `doom-ui.el`

#+begin_src emacs-lisp
(defun c/quit-p (&optional prompt)
  "Prompt before quitting Emacs if any unsaved files exist."
  (let ((modified-buffers (seq-filter #'buffer-modified-p (buffer-list))))
    (or (null modified-buffers)
        (yes-or-no-p (format "Quit with %d modified buffer(s)? "
                            (length modified-buffers))))))
;; A simple confirmation prompt when killing Emacs. But only prompt when there
;; are real buffers open.
(setq confirm-kill-emacs #'c/quit-p)

(defun c/delete-frame-with-prompt ()
  "Delete the current frame, but ask for confirmation if it isn't empty."
  (interactive)
  (if (cdr (frame-list))
      (when (c/quit-p "Close frame?")
        (delete-frame))
    (save-buffers-kill-emacs)))
;; Prompt for confirmation when deleting a non-empty frame; a last line of
;; defense against accidental loss of work.
(global-set-key [remap delete-frame] #'c/delete-frame-with-prompt)

;;Don't prompt for confirmation when we create a new file or buffer (assume the
;; user knows what they're doing).
(setq confirm-nonexistent-file-or-buffer nil)

(setq uniquify-buffer-name-style 'forward
      ;; no beeping or blinking please
      ring-bell-function #'ignore
      visible-bell nil)
#+end_src

** Scrolling
Copied this from `doom-ui.el`

#+begin_src emacs-lisp
;;; Scrolling
(setq hscroll-margin 2
      hscroll-step 1
      ;; Emacs spends too much effort recentering the screen if you scroll the
      ;; cursor more than N lines past window edges (where N is the settings of
      ;; `scroll-conservatively'). This is especially slow in larger files
      ;; during large-scale scrolling commands. If kept over 100, the window is
      ;; never automatically recentered. The default (0) triggers this too
      ;; aggressively, so I've set it to 10 to recenter if scrolling too far
      ;; off-screen.
      scroll-conservatively 10
      scroll-margin 0
      scroll-preserve-screen-position t
      ;; Reduce cursor lag by a tiny bit by not auto-adjusting `window-vscroll'
      ;; for tall lines.
      auto-window-vscroll nil
      ;; mouse
      mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
      mouse-wheel-scroll-amount-horizontal 2)
#+end_src

** Nano Theme

#+begin_src emacs-lisp
(use-package nano-theme
  :ensure (nano-theme :host github :repo "aaronjensen/nano-theme" :protocol ssh)
  :config
  ;; Vertical window divider
  (setq window-divider-default-right-width 1)
  (setq window-divider-default-bottom-width 1)
  (setq window-divider-default-places t)
  (window-divider-mode 1)

  ;; No ugly button for checkboxes
  (setq widget-image-enable nil)

  (setq
   nano-window-divider-show t

   nano-light-background "#FFFFFF"          ;; White
   nano-light-highlight "#F9FAFB"           ;; Cool Gray 50
   nano-light-background-alt "#F3F4F6"      ;; Cool Gray 100
   nano-light-subtle "#E5E7EB"              ;; Cool Gray 200
   nano-light-fringe "#D1D5DB"              ;; Cool Gray 300
   nano-light-cursor-alt "#9CA3AF"          ;; Cool Gray 400
   nano-light-faded "#6B7280"               ;; Cool Gray 600
   nano-light-bold "#374151"                ;; Cool Gray 700
   nano-light-foreground "#1F2937"          ;; Cool Gray 800
   nano-light-foreground-alt "#111827"      ;; Cool Gray 900
   nano-light-strong "#000000"              ;; Black
   nano-light-critical "#EA580C"            ;; Orange 600
   nano-light-salient "#5B21B6"             ;; Violet 800
   nano-light-selected-background "#BAE6FD" ;; Sky 200
   nano-light-popout "#0369A1"              ;; Sky 700
   )

  (load-theme 'nano t)

  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "SF Pro" :height 150 :weight normal))))
   '(vundo-default ((t (:family "Iosevka SS04"))))))
#+end_src

** Nano Modeline

#+begin_src emacs-lisp
(use-package memoize
  :commands (memoize))

(use-package nano-modeline
  :ensure (nano-modeline :host github :repo "rougier/nano-modeline")
  :init
  (setq-default mode-line-format nil)
  (add-hook 'after-change-major-mode-hook #'c/nano-modeline)

  :preface
  (defun c/nano-modeline ()
    "Set modeline accordingly"
    (cond ((derived-mode-p 'prog-mode)
           (c/nano-modeline-prog-mode))
          ((derived-mode-p 'vterm-mode))
          (t
           (c/nano-modeline-text-mode))))

  :config
  (require 'memoize)

  ;; This is copy/pasted from nano-modeline but has the truncation removed
  (defun nano-modeline--make (left right face-prefix)
    "Build a dynamic mode/header line made of LEFT and RIGHT part,
using the given FACE-PREFIX as the default."

    `(:eval
      (let* ((nano-modeline-base-face (nano-modeline--base-face ',face-prefix))
             (left (mapconcat
                    (lambda (element)
                      (if (stringp element)
                          (propertize element 'face nano-modeline-base-face)
                        (apply (car element) (cdr element))))
                    ',left))
             (right (mapconcat
                     (lambda (element)
                       (if (stringp element)
                           (propertize element 'face nano-modeline-base-face)
                         (apply (car element) (cdr element))))
                     ',right))
             (fringe (if fringes-outside-margins 0.0 -1.0)))
        (concat (propertize " "
                            'display `(space :align-to (+ left
                                                          (,fringe . left-fringe)
                                                          (0.0 . left-margin))))
                left
                (propertize " "
                            'face `(:inherit ,nano-modeline-base-face)
                            'display `(space :align-to (- right
                                                          (,fringe . right-fringe)
                                                          (0.0 . right-margin)
                                                          ,(length right))))
                right))))

  (defun c/shorten-directory-path (path threshold)
    "Shorten a directory PATH by reducing the earlier path parts to a single letter if the PATH goes past the THRESHOLD, but never shorten the last part of the path."
    (let* ((path (abbreviate-file-name path))
           (parts (split-string path "/"))
           (shortened-parts))
      (while parts
        (let ((part (car parts)))
          (if (or (not (cdr parts))
                  (< (length (string-join (append parts shortened-parts) "/"))
                     threshold))
              (push part shortened-parts)
            (push (if (zerop (length part))
                      part
                    (substring part 0 1))
                  shortened-parts)))
        (setq parts (cdr parts)))

      (string-join (reverse shortened-parts) "/")))

  (defun c/nano-modeline-project-root ()
    "Return the current project name or nil."
    (when-let* ((project (project-current)))
      (project-root project)))

  (defun c/nano-modeline-project-name ()
    "Return the current project name or nil."
    (when-let* ((project-root (c/nano-modeline-project-root)))
      (file-name-nondirectory (directory-file-name project-root))))

  (defmemoize c/nano-modeline-project-relative-name (file-name max-width)
    (c/shorten-directory-path
     (if-let* ((project-root (c/nano-modeline-project-root)))
         (file-relative-name file-name project-root)
       file-name)
     max-width))

  (defun c/nano-modeline-buffer-file-name ()
    (when buffer-file-name
      (c/nano-modeline-project-relative-name
       (substring-no-properties buffer-file-name)
       (- (window-width) 20))))

  (defun c/nano-modeline-buffer-name (&optional name)
    (concat
     (propertize
      (or name
          (c/nano-modeline-buffer-file-name)
          (format-mode-line "%b"))
      'face (nano-modeline-face 'name))
     (propertize
      (if (and buffer-file-name
               (buffer-modified-p))
          (concat (propertize " " 'display '(space :width (3)))
                  (propertize "â¬¤" 'display '((raise 0.15) (height 0.4)))
                  (propertize " " 'display '(space :width (6))))
        (propertize " " 'display '(space :width (16))))
      'face (nano-modeline-face 'header))))

  (defvar c/nano-modeline-abbreviations
    '(("incorporation" . "inc")
      ("document" . "doc")
      ("documents" . "docs")
      ("generation" . "gen")))

  (defun c/nano-modeline-abbreviate (text)
    (with-temp-buffer
      (insert text)
      (goto-char (point-min))
      (while (re-search-forward "\\b\\w+\\b" nil t)
        (let* ((word (match-string 0))
               (abbr (assoc-default word c/nano-modeline-abbreviations)))
          (when abbr
            (replace-match abbr))))
      (buffer-string)))

  (defun c/nano-modeline-project (&rest args)
    "Current project"
    (propertize
     (let ((name (c/nano-modeline-project-name))
           (max-length 32))
       (if name
           (progn
             (when (> (length name) max-length)
               (setq name (c/nano-modeline-abbreviate name)))

             (when (> (length name) max-length)
               (setq name (concat
                           (substring name 0 (- max-length 1))
                           "â€¦")))

             (concat "[" name "]"))
         ""))
     'face (nano-modeline-face 'project)))

  (defun c/nano-modeline-window-dedicated ()
    (when (window-dedicated-p)
      (propertize "ðŸ–ˆ " 'face (nano-modeline-face 'secondary) 'display '(height 0.85))))

  (defun c/nano-modeline-prog-mode (&optional default)
    "Nano line for prog mode. Can be made DEFAULT mode."

    (funcall nano-modeline-position
             '((c/nano-modeline-window-dedicated)
               (c/nano-modeline-buffer-name)
               (c/nano-modeline-project))
             '((nano-modeline-cursor-position))
             default)

    ;; Work around Emacs limiation with header-line face introduced in Emacs 31
    ;; that prevents remapping from working properly. If nano-modeline stops
    ;; remapping, this can be removed - Aaron, Thu Dec 5 2024
    (face-remap-set-base 'header-line-active 'nano-modeline--empty-face)
    (face-remap-set-base 'header-line-inactive 'nano-modeline--empty-face))

  (defun c/nano-modeline-text-mode (&optional default)
    "Nano line for text mode. Can be made DEFAULT mode."

    (funcall nano-modeline-position
             '((c/nano-modeline-window-dedicated)
               (c/nano-modeline-buffer-name)
               (c/nano-modeline-project))
             '((nano-modeline-cursor-position))
             default)

    ;; Work around Emacs limiation with header-line face introduced in Emacs 31
    ;; that prevents remapping from working properly. If nano-modeline stops
    ;; remapping, this can be removed - Aaron, Thu Dec 5 2024
    (face-remap-set-base 'header-line-active 'nano-modeline--empty-face)
    (face-remap-set-base 'header-line-inactive 'nano-modeline--empty-face))

  (defface c/nano-modeline-name-active-face
    '((t :weight semibold
         :inherit (variable-pitch nano-modeline-active)))
    "Active name face.")
  (defface c/nano-modeline-name-inactive-face
    '((t :weight semibold
         :inherit (variable-pitch nano-faded nano-modeline-inactive)))
    "Inactive name face.")
  (defface c/nano-modeline-project-active-face
    '((t :height 0.8
         :inherit (variable-pitch nano-modeline-active)))
    "Active project face.")
  (defface c/nano-modeline-project-inactive-face
    '((t :height 0.8
         :inherit (variable-pitch nano-faded nano-modeline-inactive)))
    "Inactive project face.")
  (defface c/nano-modeline-secondary-face
    '((t :height 0.94
         :inherit (nano-faded)))
    "Secondary face.")

  (push '(name-active c/nano-modeline-name-active-face) nano-modeline-faces)
  (push '(name-inactive c/nano-modeline-name-inactive-face) nano-modeline-faces)
  (push '(project-active c/nano-modeline-project-active-face) nano-modeline-faces)
  (push '(project-inactive c/nano-modeline-project-inactive-face) nano-modeline-faces)
  (push '(secondary-active c/nano-modeline-secondary-face) nano-modeline-faces)
  (push '(secondary-inactive c/nano-modeline-secondary-face) nano-modeline-faces)

  (with-current-buffer "*Messages*"
    (c/nano-modeline)))
#+end_src

** Nano SVG Mode

#+begin_src emacs-lisp
(use-package svg-tag-mode
  :hook (org-mode . svg-tag-mode)
  :config
  (setq svg-tag-tags
        '((":DISABLED:" . ((lambda (tag) (svg-tag-make "DISABLED"))))
          ("DISABLED" . ((lambda (tag) (svg-tag-make "DISABLED")))))))
#+end_src

** Font Size

#+begin_src emacs-lisp
(use-feature emacs
  :bind (("s-=" . #'global-text-scale-adjust)
         ("s--" . #'global-text-scale-adjust)
         ("s-0" . #'global-text-scale-adjust)
         ("C-=" . #'text-scale-adjust)
         ("C--" . #'text-scale-adjust)
         ("C-0" . #'text-scale-adjust))

  :preface
  (defvar presentation-mode-font-size 21)
  (defun presentation-mode ()
    "Increase the font size for presentation."
    (interactive)
    (let* ((current-font-size (/ (face-attribute 'default :height) 10))
           (new-font-size
            (if (not (eq current-font-size presentation-mode-font-size))
                presentation-mode-font-size
              c/monospace-font-size)))
      (set-face-attribute 'default nil :height (* new-font-size 10))
      (set-face-attribute 'variable-pitch nil :height (* new-font-size 10))
      (redisplay 'force))))
#+end_src

** Tab Bar

#+begin_src emacs-lisp
(leader-key-set "t n" #'tab-new
                "t c" #'tab-close
                "t C" #'tab-close-other
                "t t" #'tab-switch
                "t r" #'tab-rename
                "t d" #'tab-window-detach
                "t TAB" #'tab-bar-switch-to-recent-tab
                "t <" #'tab-bar-move-tab-backward
                "t >" #'tab-move
                "t p" #'c/tab-switch-project
                "e e" #'c/tab-emacs-config
                "o a" #'c/tab-org-agenda
                "w u" #'tab-bar-history-back
                "w C-r" #'tab-bar-history-forward)

(use-feature tab-bar
  :after nano-theme
  :bind (("s-1" . #'tab-select)
         ("s-2" . #'tab-select)
         ("s-3" . #'tab-select)
         ("s-4" . #'tab-select)
         ("s-5" . #'tab-select)
         ("s-6" . #'tab-select)
         ("s-7" . #'tab-select)
         ("s-8" . #'tab-select)
         ("s-9" . #'tab-select)
         ("s-w" . #'tab-close)
         ("s-T" . #'tab-undo)
         ("s-}" . #'tab-next)
         ("s-{" . #'tab-previous)
         ("s-t" . #'tab-new)

         :map tab-bar-map
         ("<wheel-up>" . #'ignore)
         ("<wheel-down>" . #'ignore)

         :repeat-map tab-bar-move-repeat-map
         ("<" . #'tab-bar-move-tab-backward)
         (">" . #'tab-move)

         :repeat-map tab-bar-history-repeat-map
         ("u" . #'tab-bar-history-back)
         ("C-r" . #'tab-bar-history-forward))

  :preface
  (defun c/tab-switch-project (project-to-switch)
    "Switch to project tab and find project file.
Only if the switched to buffer is not of that project."
    (interactive (list (project-prompt-project-dir)))

    (let* ((project-name (c/project-name project-to-switch))
           (tab-name project-name)
           new-tab
           (tab-bar-new-tab-choice
            (lambda ()
              (setq new-tab t)
              (if (string= project-name (c/project-name))
                  (current-buffer)
                (let ((default-directory project-to-switch))
                  (project-find-file))))))
      (tab-bar-switch-to-tab tab-name)

      ;; When switching, open a project file if the current-buffer is not one
      (unless new-tab
        (funcall tab-bar-new-tab-choice))))

  (defun c/tab-emacs-config ()
    "Edit the `dotfile', in the current window."
    (interactive)
    (let ((tab-bar-new-tab-choice "*scratch*"))
      (tab-bar-switch-to-tab ".emacs.d")
      (find-file-existing (concat user-emacs-directory "config.org"))))

  :config
  (setq tab-bar-show t
        tab-bar-new-tab-choice t
        tab-bar-new-button nil
        tab-bar-close-button-show nil
        tab-bar-new-tab-to 'rightmost
        tab-bar-tab-name-function #'c/name-tab-by-project-or-default
        ;; If this is the default (t) the name format function below causes
        ;; emacs to hang on boot since commit ca3763af5cc2758ec71700029558e6ecc4379ea9
        tab-bar-auto-width nil)

  (tab-bar-history-mode)

  (defun c/name-tab-by-project-or-default ()
    "Return project name if in a project, or default tab-bar name if not.
The default tab-bar name uses the buffer name."
    (or (c/project-name)
        (tab-bar-tab-name-current)))

  (defun c/tab-bar--tabs-recent (&optional tabs frame)
    "Ensure that the current tab is included."
    ;; Return the list of tabs sorted by recency.
    (let* ((tabs (or tabs (funcall tab-bar-tabs-function frame))))
      (seq-sort-by (lambda (tab) (or (alist-get 'time tab) 0)) #'>
                   tabs)))

  (advice-add #'tab-bar--tabs-recent :override #'c/tab-bar--tabs-recent))
#+end_src

*** Modern Tab Styling

#+begin_src emacs-lisp
(use-package modern-tab-bar
  :after tab-bar
  :ensure (modern-tab-bar :host github :repo "aaronjensen/emacs-modern-tab-bar" :protocol ssh)
  :config
  (modern-tab-bar-mode))
#+end_src

** Full Screen

#+begin_src emacs-lisp
(setq toggle-frame-maximized t)
#+end_src

** Completion Menu (Vertico)

#+begin_src emacs-lisp
(use-package vertico
  :hook (c/first-input-hook . vertico-mode))

(use-package vertico-posframe
  :after vertico
  :config
  (setq vertico-posframe-parameters
        '((left-fringe . 12)
          (right-fringe . 12)))

  (vertico-multiform-mode -1)
  (vertico-posframe-mode 1))
#+end_src

** Completion At Point
*** Additional Completion-at-Point Functions (cape)

#+begin_src emacs-lisp
(use-package cape
  :hook (completion-at-point-functions . cape-elisp-block)
  :config
  (setq cape-dabbrev-check-other-buffers nil))
#+end_src

*** Ripgrep Completion-at-Point Function

#+begin_src emacs-lisp
(use-package ripgrep-capf
  :after cape
  :commands (ripgrep-capf)
  :ensure (:host github :repo "aaronjensen/ripgrep-capf" :protocol ssh)
  :config
  (defalias 'capf-dabbrev-ripgrep (cape-capf-super #'cape-dabbrev #'ripgrep-capf)))
#+end_src

*** Inline Completion (Corfu)

#+begin_src emacs-lisp
(use-package corfu
  :hook (c/first-buffer-hook . corfu-history-mode)
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
        ("C-n" . nil)
        ("C-p" . nil)
        ([remap next-line] . nil)
        ([remap previous-line] . nil)
        ([remap move-end-of-line] . nil)
        ([remap move-beginning-of-line] . nil)
        ("\r" . nil)
        ("<escape>" . corfu-quit))
  :init
  ;; Tab will trigger completion if it does not need to indent
  (setq tab-always-indent 'complete)
  ;; Disable text-mode ispell completion at point function
  (setq text-mode-ispell-word-completion nil)
  ;; TAB-and-Go customizations
  (setq
   ;; Enable cycling for `corfu-next/previous'
   corfu-cycle t
   corfu-preselect 'prompt)
  ;; Auto completion
  (setq
   corfu-auto t
   corfu-auto-prefix 2
   corfu-auto-delay 0.1))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  :bind (("C-x b" . consult-buffer)))
#+end_src

** Completion Style (Orderless)

The orderless completion style allows typing parts of what is being matched,
separated by spaces. For example, "som thi" will match "this-is-some-thing".

#+begin_src emacs-lisp
(use-package orderless
  :config
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Minibuffer Annotations (Marginalia)

#+begin_src emacs-lisp
(use-package marginalia
  :hook (c/first-input-hook . marginalia-mode)
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  :bind (:map minibuffer-local-map
              ("M-A" . marginalia-cycle)))
#+end_src

** Minibuffer Actions Rooted in Keybindings (Embark)

#+begin_src emacs-lisp
(use-package embark
  :commands (embark-export embark-act)
  :bind (:map
         vertico-map
         ("C-c C-o" . #'embark-export)
         ("C-c C-c" . #'embark-act)
         ("C-c C-e" . #'c/embark-export-wgrep))
  :preface
  (defvar c/embark-export-wgrep nil)
  (defun c/embark-export-wgrep ()
    "Embark export then wgrep"
    (interactive)
    (setq c/embark-export-wgrep t)
    (command-execute #'embark-export))
  :config
  (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))
  (setq embark-indicators
        '(embark-minimal-indicator  ; default is embark-mixed-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator)))

(use-package embark-consult
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  :config
  (declare-function wgrep-change-to-wgrep-mode "ext:wgrep")
  (defun c/embark-export-grep-wgrep (&rest _)
    "Start wgrep when indicated"
    (when c/embark-export-wgrep
      (setq c/embark-export-wgrep nil)
      (when (eq major-mode 'grep-mode)
        (wgrep-change-to-wgrep-mode))))
  (advice-add #'embark-consult-export-grep :after #'c/embark-export-grep-wgrep))
#+end_src

** DISABLED Miniframe
Disabled this is favor of using vertico-posframe. embark was opening a new frame.

#+begin_src emacs-lisp
(use-package mini-frame
  :hook (c/first-input-hook . mini-frame-mode)
  :config
  (custom-set-variables
   '(mini-frame-show-parameters
     '((top . 0.4)
       (width . 0.8)
       (left . 0.5)
       (height . 5)
       (left-fringe . 12)
       (right-fringe . 12)
       (child-frame-border-width . 1)
       (internal-border-width . 1)))
   '(mini-frame-color-shift-step 7))
  (setq mini-frame-internal-border-color "black"
        mini-frame-ignore-commands (append mini-frame-ignore-commands '(evil-ex embark-act))))
#+end_src

* Text Editing
** Delete Trailing Whitespace

#+begin_src emacs-lisp
(use-package ws-butler
  :hook (c/first-file-hook . ws-butler-global-mode))
#+end_src

** Spell Checking (Flyspell)

#+begin_src emacs-lisp
(use-feature flyspell
  :hook ((org-mode git-commit-mode markdown-mode) . flyspell-mode)
  :config
  (setq flyspell-issue-message-flag nil
        flyspell-issue-welcome-flag nil))
#+end_src

** Editing Search Results (wgrep)

#+begin_src emacs-lisp
(use-package wgrep
  :commands (wgrep-change-to-wgrep-mode)
  :config
  (setq wgrep-auto-save-buffer t))
#+end_src

* Projects
** DISABLED [[https://github.com/aurtzy/disproject][Disproject]]

Transient menus for project.el

#+begin_src emacs-lisp
(use-package disproject
  ;; Replace `project-prefix-map' with `disproject-dispatch'.
  :bind ( :map ctl-x-map
          ("p" . disproject-dispatch)))

(leader-key-set
 "p p" #'disproject-dispatch)
#+end_src

** Utility Functions

#+begin_src emacs-lisp
(defun c/project-name (&optional project-root)
  "Return the current project name or nil."
  (when-let* ((project-root (or project-root
                                (c/project-root))))
    (file-name-nondirectory (directory-file-name project-root))))

(defun c/project-root ()
  "Return the current project name or nil."
  (when-let* ((project (project-current)))
    (project-root project)))

(defun c/search-project-for-symbol ()
  "Search current project for symbol at point using ripgrep.
With prefix arg (C-u), prompt for a project directory to search in."
  (interactive)
  (let* ((symbol (or (thing-at-point 'symbol t) ""))
         (dir (if current-prefix-arg
                  (project-prompt-project-dir)  ; when C-u is pressed
                (project-root (project-current)))))
    (consult-ripgrep dir (regexp-quote symbol))))
#+end_src

** Tree View (Treemacs)

#+begin_src emacs-lisp
(use-package all-the-icons)

(use-package treemacs
  :bind ("s-b" . #'treemacs)
  :commands (treemacs)
  :hook (treemacs-mode-hook . c/treemacs-line-spacing)
  :config
  (defun c/treemacs-line-spacing ()
    "Disable line spacing for treemacs."
    (setq line-spacing nil))

  (add-hook 'treemacs-mode-hook #'c/treemacs-line-spacing)

  (setq treemacs-user-mode-line-format 'none
        treemacs-is-never-other-window t
        treemacs-sorting 'alphabetic-case-insensitive-asc
        treemacs-wrap-around nil
        treemacs-collapse-dirs 0
        ;; Don't indent under the root, but indent everywhere else
        ;; 20 indentation levels should be enough - Aaron, Sat May 06 2023
        treemacs-indentation-string (cons "" (make-list 20 (propertize " " 'display '(space-width 1.0)))))

  (treemacs-follow-mode t)
  (treemacs-filewatch-mode t)
  (treemacs-fringe-indicator-mode t)

  (require 'all-the-icons)

  (treemacs-create-theme "simple"
    :config
    (progn
      (treemacs-create-icon :icon (format "%s\t" (all-the-icons-octicon "repo" :height 1.2 :v-adjust -0.1 :face 'font-lock-string-face))
                            :extensions (root-closed root-open)
                            :fallback 'same-as-icon)
      (treemacs-create-icon :icon (format "%s%s" (all-the-icons-material "expand_more" :height 0.8 :face 'font-lock-doc-face)
                                          (propertize " " 'display '(space . (:width (4)))))
                            :extensions (dir-open)
                            :fallback 'same-as-icon)
      (treemacs-create-icon :icon (format "%s%s" (all-the-icons-material "chevron_right" :height 0.8 :face 'font-lock-doc-face)
                                          (propertize " " 'display '(space . (:width (4)))))
                            :extensions (dir-closed)
                            :fallback 'same-as-icon)
      (treemacs-create-icon :icon (propertize " " 'display '(space . (:width (18))))
                            :extensions (fallback)
                            :fallback 'same-as-icon)))
  (treemacs-load-theme "simple"))

(use-package treemacs-evil
  :after (treemacs evil)
  :demand t)

(use-package treemacs-magit
  :after (treemacs magit)
  :demand t)

(use-package treemacs-tab-bar
  :after (treemacs)
  :demand t
  :config
  (treemacs-set-scope-type 'Tabs))
#+end_src

** Workspaces (Tabspaces)

#+begin_src emacs-lisp
(use-package tabspaces
  :after consult
  :hook (c/after-input-hook . tabspaces-mode)
  :commands (tabspaces-mode)
  :init
  (setq tabspaces-session-file (no-littering-expand-var-file-name "tabsession.el")
        tabspaces-project-switch-commands #'project-find-file)
  :config
  (consult-customize consult--source-buffer :hidden t :default nil)

  ;; set consult-workspace buffer list
  (defvar consult--source-workspace
    (list :name "Workspace Buffers"
          :narrow ?w
          :history 'buffer-name-history
          :category 'buffer
          :state #'consult--buffer-state
          :default t
          :items (lambda () (consult--buffer-query
                             :predicate #'tabspaces--local-buffer-p
                             :sort 'visibility
                             :as #'buffer-name)))

    "Set workspace buffer list for consult-buffer.")
  (add-to-list 'consult-buffer-sources 'consult--source-workspace))
#+end_src

* File Types
** Defaults
*** Indentation

Two space indentation by default.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2
              smie-indent-basic 2)
#+end_src

** Shell

#+begin_src emacs-lisp
(use-feature shell
  :config
  (setq sh-basic-offset 2))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode)
  :hook ((markdown-mode-hook . visual-line-mode)
         (markdown-mode-hook . visual-wrap-prefix-mode))

  :config
  (setq markdown-list-indent-width 2))
#+end_src

** Ruby

#+begin_src emacs-lisp
(use-feature ruby-mode
  :commands (ruby-mode)
  :hook (ruby-mode . corfu-mode)
  :capf capf-dabbrev-ripgrep
  :config
  (setq ruby-block-indent nil
        ruby-method-call-indent nil
        ruby-method-params-indent nil
        ruby-after-operator-indent nil
        ruby-bracketed-args-indent nil))
#+end_src

* Version Control
** Magit

#+begin_src emacs-lisp
(use-package magit
  :commands (magit-status)
  :hook (magit-diff-mode-hook . (lambda ()
                                  (setq truncate-lines nil)))
  :config
  (setq magit-display-buffer-function 'magit-display-buffer-fullframe-status-topleft-v1)
  (setq magit-bury-buffer-function 'magit-restore-window-configuration)

  (add-hook 'git-commit-setup-hook
            (defun +vc-start-in-insert-state-maybe-h ()
              "Start git-commit-mode in insert state if in a blank commit message, otherwise in default state."
              (when (and (bound-and-true-p evil-local-mode)
                         (not (evil-emacs-state-p))
                         (bobp) (eolp))
                (evil-insert-state)))))
#+end_src

Install latest version of transient, as the version included in Emacs is not recent enough.

#+begin_src emacs-lisp
(use-package transient
  :after (magit))
#+end_src

* Assistance
** Which Key

#+begin_src emacs-lisp
(use-feature which-key
  :hook (c/first-input-hook . which-key-mode))
#+end_src

** Helpful

#+begin_src emacs-lisp
(use-package helpful
  :hook (helpful-mode . visual-line-mode)
  :commands (helpful-callable helpful-command helpful-variable helpful-symbol helpful-key)
  :bind (
         ;; Remap standard commands
         ([remap describe-function] . #'helpful-callable)
         ([remap describe-command] . #'helpful-command)
         ([remap describe-variable] . #'helpful-variable)
         ([remap describe-symbol] . #'helpful-symbol)
         ([remap describe-key] . #'helpful-key)))
#+end_src

* Undo
** Vundo

#+begin_src emacs-lisp
(use-package vundo
  :commands (vundo))
#+end_src

** Undo Fu Session

#+begin_src emacs-lisp
(use-package undo-fu-session
  :hook (c/first-file-hook .  undo-fu-session-global-mode)
  :config
  (setq undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))
#+end_src

* Major Modes
** Org

#+begin_src emacs-lisp
(use-feature org
  :hook ((org-mode . corfu-mode)
         (org-mode . visual-line-mode))
  :config
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))

  (setq org-default-notes-file "~/code/personal/emacs-configuration-example/notes.org")

  (setq org-capture-templates
        '(("c" "Config To Do" entry (file+headline "~/code/personal/emacs-configuration-example/notes.org" "To Dos")
           "* TODO %?\n  %i\n  %a")))

  (setq org-edit-src-content-indentation 0
        org-hide-emphasis-markers t)

  (defun c/capture-config-todo ()
    (interactive)
    (org-capture nil "c"))

  (leader-key-set "c" #'c/capture-config-todo))

(use-package org-superstar
  :hook (org-mode . org-superstar-mode)
  :config
  (setq org-superstar-leading-bullet ?\s
        org-superstar-leading-fallback ?\s
        org-superstar-configure-like-org-bullets t
        org-hide-leading-stars nil))

(use-package org-appear
  :hook (org-mode . org-appear-mode))
#+end_src

** Dired

#+begin_src emacs-lisp
(use-feature dired
  :hook (dired-mode-hook. dired-hide-details-mode))
#+end_src

* Minor Modes
** Parens

#+begin_src emacs-lisp
(use-package smartparens
  :hook (c/first-buffer-hook . smartparens-global-mode))

(use-package rainbow-delimiters
  :hook ((org-mode . rainbow-delimiters-mode)
         (emacs-lisp-mode . rainbow-delimiters-mode)))
#+end_src

** Line Numbers

#+begin_src emacs-lisp
(setq display-line-numbers-type 't)  ; Options: 'relative, 't (absolute), 'visual
(setq display-line-numbers-width 3)         ; Adjust width of line number display
(setq display-line-numbers-grow-only t)     ; Prevent width from shrinking

(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

* Terminal
** Terminal Emulator (vterm)

#+begin_src emacs-lisp
(use-package vterm
  :hook (vterm-mode-hook . (lambda ()
                             (setq confirm-kill-processes nil
                                   hscroll-margin 0)))
  :commands (vterm vterm-mode)
  :bind (:map vterm-mode-map
              ("C-q" . vterm-send-next-key))
  :preface
  ;; HACK Because vterm clusmily forces vterm-module.so's compilation on us when
  ;;      the package is loaded, this is necessary to prevent it when
  ;;      byte-compiling this file (`use-package' blocks eagerly loads packages
  ;;      when compiled).
  (when noninteractive
    (advice-add #'vterm-module-compile :override #'ignore)
    (provide 'vterm-module))

  :config
  (setq vterm-always-compile-module t
        ;; Defaults to 0.1. Decreasing this greatly impacts performance of
        ;; rendering large batches of text.
        vterm-timer-delay 0.06)

  ;; Once vterm is dead, the vterm buffer is useless. Why keep it around? We can
  ;; spawn another if want one.
  (setq vterm-kill-buffer-on-exit t)

  ;; 5000 lines of scrollback, instead of 1000
  (setq vterm-max-scrollback 5000))
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package vterm-toggle
  :bind (("s-i" . vterm-toggle))
  :config
  (setq vterm-toggle-scope 'project
        vterm-toggle-project-root t))
#+end_src

* Test packages
** DISABLED Transient showcase

#+begin_src emacs-lisp
(use-package transient-showcase
  :ensure (transient-showcase :host github :repo "positron-solutions/transient-showcase" :protocol ssh))
#+end_src

** DISABLED pgmacs

#+begin_src emacs-lisp
(use-package pgmacs
  :commands (pgmacs)
  :ensure (pgmacs :host github :repo "emarsden/pgmacs" :protocol ssh)
  :defer t)

#+end_src

** DISABLED message-db-viewer

#+begin_src emacs-lisp
(use-package message-db
  :ensure (message-db :host github :repo "gringocl/message-db.el"))
#+end_src
* Startup Time

#+begin_src emacs-lisp
(add-hook 'elpaca-after-init-hook
          (lambda ()
            (let ((inhibit-message t))
              (message "Emacs init time: %s" (emacs-init-time)))))
#+end_src

#+title: Emacs Config
#+startup: overview
#+TODO: DISABLED

* Things to do
** Window movement
  - vterm
** New window placement for magit and vterm
** Mouse over tabs doesn't change
** `c/project-name` missing
* Utility Functions
** Hooks

#+begin_src emacs-lisp
(define-error 'c/hook-error "Error in a startup hook" 'c/error)

(defmacro c/add-transient-hook (name hook-or-function &rest forms)
  "Attaches a self-removing function to HOOK-OR-FUNCTION.

FORMS are evaluated once, when that function/hook is first invoked, then never
again.

HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
advised)."
  (declare (indent 1))
  (let ((append (if (eq (car forms) :after) (pop forms)))
        ;; Avoid `make-symbol' and `gensym' here because an interned symbol is
        ;; easier to debug in backtraces (and is visible to `describe-function')
        (fn name))
    `(let ((sym ,hook-or-function))
       (defun ,fn (&rest _)
         ,(format "Transient hook for %S" (c/unquote hook-or-function))
         ,@forms
         (let ((sym ,hook-or-function))
           (cond ((functionp sym) (advice-remove sym #',fn))
                 ((symbolp sym)   (remove-hook sym #',fn))))
         (unintern ',fn nil))
       (cond ((functionp sym)
              (advice-add ,hook-or-function ,(if append :after :before) #',fn))
             ((symbolp sym)
              (put ',fn 'permanent-local-hook t)
              (add-hook sym #',fn ,append))))))

(defvar c/time-hooks nil)

(defun c/run-hook (hook)
  "Run HOOK (a hook function) with better error handling.
Meant to be used with `run-hook-wrapped'."
  (condition-case-unless-debug e
      (if c/time-hooks
          (let ((time (current-time)))
            (funcall hook)
            (let ((inhibit-message t)
                  (elapsed-time (* 1000 (float-time (time-subtract (current-time) time)))))
              (when (> elapsed-time 2)
                (message "%S â€¢ %4dms â€¢ %S" c/time-hooks elapsed-time hook))))
        (funcall hook))
    (error
     (signal 'c/hook-error (list hook e))))
  ;; return nil so `run-hook-wrapped' won't short circuit
  nil)

(defun c/run-hooks (&rest hooks)
  "Run HOOKS (a list of hook variable symbols) with better error handling.
Is used as advice to replace `run-hooks'."
  (dolist (hook hooks)
    (condition-case-unless-debug e
        (run-hook-wrapped hook #'c/run-hook)
      (c/hook-error
       (unless debug-on-error
         (lwarn hook :error "Error running hook %S because: %s"
                (if (symbolp (cadr e))
                    (symbol-name (cadr e))
                  (cadr e))
                (caddr e)))
       (signal 'c/hook-error (cons hook (cdr e)))))))

(defun c/run-hook-on (hook-var trigger-hooks)
  "Configure HOOK-VAR to be invoked exactly once when any of the TRIGGER-HOOKS
are invoked *after* Emacs has initialized (to reduce false positives). Once
HOOK-VAR is triggered, it is reset to nil.

HOOK-VAR is a quoted hook.
TRIGGER-HOOK is a list of quoted hooks and/or sharp-quoted functions."
  (dolist (hook trigger-hooks)
    (let ((fn (intern (format "%s-init-on-%s-h" hook-var hook))))
      (fset
       fn (lambda (&rest _)
            ;; Only trigger this after Emacs has initialized.
            (when (and after-init-time
                       (or (daemonp)
                           ;; In some cases, hooks may be lexically unset to
                           ;; inhibit them during expensive batch operations on
                           ;; buffers (such as when processing buffers
                           ;; internally). In these cases we should assume this
                           ;; hook wasn't invoked interactively.
                           (and (boundp hook)
                                (symbol-value hook))))
              (let ((c/time-hooks hook-var))
                (c/run-hooks hook-var))
              (set hook-var nil))))
      (cond ((daemonp)
             ;; In a daemon session we don't need all these lazy loading
             ;; shenanigans. Just load everything immediately.
             (add-hook 'after-init-hook fn 'append))
            ((eq hook 'find-file-hook)
             ;; Advise `after-find-file' instead of using `find-file-hook'
             ;; because the latter is triggered too late (after the file has
             ;; opened and modes are all set up).
             (advice-add 'after-find-file :before fn '((depth . -101))))
            ((add-hook hook fn -101)))
      fn)))

;; Produce more helpful (and visible) error messages from errors emitted from
;; hooks (particularly mode hooks, that usually go unnoticed otherwise.
(advice-add #'run-hooks :override #'c/run-hooks)

(defvar c/first-input-hook nil
  "Transient hooks run before the first user input.")
(put 'c/first-input-hook 'permanent-local t)

(defvar c/first-file-hook nil
  "Transient hooks run before the first interactively opened file.")
(put 'c/first-file-hook 'permanent-local t)

(defvar c/first-buffer-hook nil
  "Transient hooks run before the first interactively opened buffer.")
(put 'c/first-buffer-hook 'permanent-local t)

(defvar c/switch-buffer-hook nil
  "A list of hooks run after changing the current buffer.")

(defun c/run-switch-buffer-hooks-h (&optional _)
  (let ((gc-cons-threshold most-positive-fixnum)
        (inhibit-redisplay t))
    (run-hooks 'c/switch-buffer-hook)))

(defun c/init-switch-buffer-hook (&optional _)
  "Initialize user interface by applying its hooks.
These should be done as late as possible, as to avoid/minimize prematurely
triggering hooks during startup."

  (c/run-hook-on 'c/first-buffer-hook '(find-file-hook c/switch-buffer-hook))

  ;; Only run this once
  (remove-hook 'window-buffer-change-functions #'c/init-switch-buffer-hook))

;; Initialize `c/switch-buffer-hook'
(add-hook 'window-buffer-change-functions #'c/run-switch-buffer-hooks-h)
;; `window-buffer-change-functions' doesn't trigger for files visited via the server.
(add-hook 'server-visit-hook #'c/run-switch-buffer-hooks-h)

(unless noninteractive
  ;; Initialize UI as late as possible. `window-buffer-change-functions' runs
  ;; once, when the scratch/dashboard buffer is first displayed.
  (add-hook 'window-buffer-change-functions #'c/init-switch-buffer-hook 99)
  (c/run-hook-on 'c/first-input-hook '(pre-command-hook))
  (c/run-hook-on 'c/first-file-hook '(find-file-hook dired-initial-position-hook)))(defvar c/first-input-hook nil
  "Transient hooks run before the first user input.")
(put 'c/first-input-hook 'permanent-local t)

(defvar c/first-file-hook nil
  "Transient hooks run before the first interactively opened file.")
(put 'c/first-file-hook 'permanent-local t)

(unless noninteractive
  ;; Initialize UI as late as possible. `window-buffer-change-functions' runs
  ;; once, when the scratch/dashboard buffer is first displayed.
  (add-hook 'window-buffer-change-functions #'c/init-switch-buffer-hook 99)
  (c/run-hook-on 'c/first-input-hook '(pre-command-hook))
  (c/run-hook-on 'c/first-file-hook '(find-file-hook dired-initial-position-hook)))

(defun c/run-hook-on (hook-var trigger-hooks)
  "Configure HOOK-VAR to be invoked exactly once when any of the TRIGGER-HOOKS
are invoked *after* Emacs has initialized (to reduce false positives). Once
HOOK-VAR is triggered, it is reset to nil.

HOOK-VAR is a quoted hook.
TRIGGER-HOOK is a list of quoted hooks and/or sharp-quoted functions."
  (dolist (hook trigger-hooks)
    (let ((fn (intern (format "%s-init-on-%s-h" hook-var hook))))
      (fset
       fn (lambda (&rest _)
            ;; Only trigger this after Emacs has initialized.
            (when (and after-init-time
                       (or (daemonp)
                           ;; In some cases, hooks may be lexically unset to
                           ;; inhibit them during expensive batch operations on
                           ;; buffers (such as when processing buffers
                           ;; internally). In these cases we should assume this
                           ;; hook wasn't invoked interactively.
                           (and (boundp hook)
                                (symbol-value hook))))
              (let ((c/time-hooks hook-var))
                (c/run-hooks hook-var))
              (set hook-var nil))))
      (cond ((daemonp)
             ;; In a daemon session we don't need all these lazy loading
             ;; shenanigans. Just load everything immediately.
             (add-hook 'after-init-hook fn 'append))
            ((eq hook 'find-file-hook)
             ;; Advise `after-find-file' instead of using `find-file-hook'
             ;; because the latter is triggered too late (after the file has
             ;; opened and modes are all set up).
             (advice-add 'after-find-file :before fn '((depth . -101))))
            ((add-hook hook fn -101)))
      fn)))
#+end_src

* Initial packages

The two packages are the first to load in the configuration

** Leader Key

#+begin_src emacs-lisp
(use-package leader-key
  :ensure (leader-key :host github :repo "aaronjensen/emacs-leader-key" :protocol ssh :wait t)
  :demand t
  :config
  (leader-key-init)

  (leader-key-declare-prefix "a" "apps" "Applications")
  (leader-key-declare-prefix "b" "buffers" "Buffers")
  (leader-key-declare-prefix "e p" "profiler" "Profiler")
  (leader-key-declare-prefix "e" "emacs" "Emacs")
  (leader-key-declare-prefix "f" "files" "Files")
  (leader-key-declare-prefix "g" "git" "Git")
  (leader-key-declare-prefix "h" "help" "Help")
  (leader-key-declare-prefix "j" "journal" "Journal")
  (leader-key-declare-prefix "l" "layouts" "Layouts")
  (leader-key-declare-prefix "m" "major" "Major Mode")
  (leader-key-declare-prefix "n" "notes" "Notes")
  (leader-key-declare-prefix "o" "org" "Org Mode")
  (leader-key-declare-prefix "p" "projects" "Projects")
  (leader-key-declare-prefix "q" "quit" "Quit Emacs")
  (leader-key-declare-prefix "r" "error" "Error")
  (leader-key-declare-prefix "S" "flyspell" "Flyspell")
  (leader-key-declare-prefix "s" "search" "Search")
  (leader-key-declare-prefix "T" "toggle" "Toggle")
  (leader-key-declare-prefix "u" "C-u" "Universal Argument")
  (leader-key-declare-prefix "w" "windows" "Windows")

  (leader-key-set
   "a g" #'gptel-menu
   "b b" #'consult-buffer
   "h k" #'describe-key
   "h v" #'describe-variable
   "h f" #'describe-function
   "g g" #'magit-status
   "f f" #'find-file
   "x" #'execute-extended-command
   "u" #'universal-argument
   ";" #'evilnc-comment-operator
   "/" #'consult-ripgrep
   "TAB" #'evil-switch-to-windows-last-buffer
   "e l" #'find-library
   "q r" #'restart-emacs
   "s u" #'vundo
   "T w" #'visual-line-mode))
#+end_src

** Compdef

Add =:capf= and =:compdef= to =use-package=.

#+begin_src emacs-lisp
(use-package compdef
  :ensure (:wait t))
#+end_src

* LLM Chat

** gptel

#+begin_src emacs-lisp
(use-package gptel
  :defer t
  :commands (gptel gptel-menu gptel-send gptel-request)
  :config
  (defun ms/load-anthropic-key ()
    (gptel-api-key-from-auth-source "api.anthropic.com"))

  (gptel-make-anthropic "Claude"
                        :stream t
                        :key #'ms/load-anthropic-key
                        :models '(claude-3-5-sonnet-20241022))

  (setq
   gptel-model "mistral-nemo:12b"
   gptel-backend (gptel-make-ollama "Ollama"
                                    :host "ollama.diffusenebula.org"
                                    :stream t
                                    :models '(mistral-nemo:12b
                                              mistral-nemo:12b-instruct-2407-q6_K))))
#+end_src


#+begin_src emacs-lisp
(use-package whisper
  :ensure (:host github :repo "natrys/whisper.el" :protocol ssh :wait t)
  :bind ("C-H-r" . whisper-run)
  :config
  (setq whisper-install-directory "/tmp/"
        whisper-model "base"
        whisper-language "en"
        whisper-translate nil
        whisper-use-threads (/ (num-processors) 2)))


(defun rk/get-ffmpeg-device ()
  "Gets the list of devices available to ffmpeg.
The output of the ffmpeg command is pretty messy, e.g.
  [AVFoundation indev @ 0x7f867f004580] AVFoundation video devices:
  [AVFoundation indev @ 0x7f867f004580] [0] FaceTime HD Camera (Built-in)
  [AVFoundation indev @ 0x7f867f004580] AVFoundation audio devices:
  [AVFoundation indev @ 0x7f867f004580] [0] Cam Link 4K
  [AVFoundation indev @ 0x7f867f004580] [1] MacBook Pro Microphone
so we need to parse it to get the list of devices.
The return value contains two lists, one for video devices and one for audio devices.
Each list contains a list of cons cells, where the car is the device number and the cdr is the device name."
  (unless (string-equal system-type "darwin")
    (error "This function is currently only supported on macOS"))

  (let ((lines (string-split (shell-command-to-string "ffmpeg -list_devices true -f avfoundation -i dummy || true") "\n")))
    (cl-loop with at-video-devices = nil
             with at-audio-devices = nil
             with video-devices = nil
             with audio-devices = nil
             for line in lines
             when (string-match "AVFoundation video devices:" line)
             do (setq at-video-devices t
                      at-audio-devices nil)
             when (string-match "AVFoundation audio devices:" line)
             do (setq at-audio-devices t
                      at-video-devices nil)
             when (and at-video-devices
                       (string-match "\\[\\([0-9]+\\)\\] \\(.+\\)" line))
             do (push (cons (string-to-number (match-string 1 line)) (match-string 2 line)) video-devices)
             when (and at-audio-devices
                       (string-match "\\[\\([0-9]+\\)\\] \\(.+\\)" line))
             do (push (cons (string-to-number (match-string 1 line)) (match-string 2 line)) audio-devices)
             finally return (list (nreverse video-devices) (nreverse audio-devices)))))

(defun rk/find-device-matching (string type)
  "Get the devices from `rk/get-ffmpeg-device' and look for a device
matching `STRING'. `TYPE' can be :video or :audio."
  (let* ((devices (rk/get-ffmpeg-device))
         (device-list (if (eq type :video)
                          (car devices)
                        (cadr devices))))
    (cl-loop for device in device-list
             when (string-match-p string (cdr device))
             return (car device))))

(defcustom rk/default-audio-device nil
  "The default audio device to use for whisper.el and outher audio processes."
  :type 'string)

(defun rk/select-default-audio-device (&optional device-name)
  "Interactively select an audio device to use for whisper.el and other audio processes.
If `DEVICE-NAME' is provided, it will be used instead of prompting the user."
  (interactive)
  (let* ((audio-devices (cadr (rk/get-ffmpeg-device)))
         (indexes (mapcar #'car audio-devices))
         (names (mapcar #'cdr audio-devices))
         (name (or device-name (completing-read "Select audio device: " names nil t))))
    (setq rk/default-audio-device (rk/find-device-matching name :audio))
    (when (boundp 'whisper--ffmpeg-input-device)
      (setq whisper--ffmpeg-input-device (format ":%s" rk/default-audio-device)))))

#+end_src

* Package Management

** Use Package

Install packages by default when configured with use-package.

#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src

Macro to use to configure built-in features, rather than packages that do not need to be installed

#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "`use-package' with package installation (`ensure') disabled."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))
#+end_src

* Base Settings

** General

#+begin_src emacs-lisp
  (setq initial-buffer-choice
    (lambda () (get-buffer "*Messages*")))
;:(setq initial-buffer-choice "~/code/personal/emacs-configuration-example/config.org")
  (setq create-lock-files nil)
#+end_src

** C-g more helpful

Copied from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/][Prot's config]]

#+begin_src emacs-lisp
(defun c/keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

(define-key global-map (kbd "C-g") #'c/keyboard-quit-dwim)
#+end_src

** Pin Entry

#+begin_src emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+end_src

** Customization Saving

Do not save customizations in =init.el=, instead save them in a temporary file
that will be discarded. As a result, any customizations made in a session will
not be persisted across sessions.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name
                   (format "custom-%d-%d.el" (emacs-pid) (random))
                   temporary-file-directory))
#+end_src

** No Littering

Move all common files typically written to the =user-emacs-directory= to the =var=
and =etc= subdirectories so that they can be included in =.gitignore=

#+begin_src emacs-lisp
(use-package no-littering
  :ensure (:wait t))
#+end_src

** Minibuffer

Support opening new minibuffers from inside existing minibuffers.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

Do not allow the cursor in the minibuffer prompt.

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))

(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

** Save History

#+begin_src emacs-lisp
(use-feature savehist
  :init
  (savehist-mode))
#+end_src

** Backup and Auto-Save

Put backup files and auto-save files in var directory, rather than alongside the
original files.

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backup/"))))
(add-hook 'elpaca-after-init-hook
          (lambda ()
            (setq auto-save-list-file-prefix (no-littering-expand-var-file-name "auto-save/sessions/")
                  auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))))
#+end_src

When paths are too long, there can be errors when auto-save and backup filenames
are generated. This uses a consistent hash, rather than the full path to
generate the filenames. This is taken from Doom Emacs.
#+begin_src emacs-lisp
(defun c/make-auto-save-file-name-hashed (fn)
  "Compress the auto-save file name so paths don't get too long."
  (let ((buffer-file-name
         (if (or (null buffer-file-name)
                 (find-file-name-handler buffer-file-name 'make-auto-save-file-name))
             buffer-file-name
           (sha1 buffer-file-name))))
    (funcall fn)))
(advice-add #'make-auto-save-file-name :around #'c/make-auto-save-file-name-hashed)

(defun c/make-backup-file-name-hashed (fn file)
  "A few places use the backup file name so paths don't get too long."
  (let ((alist backup-directory-alist)
        backup-directory)
    (while alist
      (let ((elt (car alist)))
        (if (string-match (car elt) file)
            (setq backup-directory (cdr elt) alist nil)
          (setq alist (cdr alist)))))
    (let ((file (funcall fn file)))
      (if (or (null backup-directory)
              (not (file-name-absolute-p backup-directory)))
          file
        (expand-file-name (sha1 (file-name-nondirectory file))
                          (file-name-directory file))))))
(advice-add #'make-backup-file-name-1 :around #'c/make-backup-file-name-hashed)
#+end_src

* Evil

** Evil

#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-keybinding nil
        evil-disable-insert-state-bindings t
        evil-respect-visual-line-mode t)
  :config
  (evil-mode 1)
  (customize-set-variable 'evil-undo-system 'undo-redo))
#+end_src

** Evil Org

#+begin_src emacs-lisp
(use-package evil-org
  :after org
  :hook (org-mode . evil-org-mode))
#+end_src

** Evil Escape

#+begin_src emacs-lisp
(use-package evil-escape
  :after evil
  :hook (pre-command . evil-escape-mode)
  :init
  (setq evil-escape-key-sequence "jk"
        evil-escape-delay 0.2)
  (evil-define-key* '(insert replace visual operator) 'global "\C-g" #'evil-escape))
#+end_src

** Evil Collection

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src

** Evil Nerd Comment

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :commands (evilnc-comment-operator)
  :bind (
   ([remap comment-line] . #'evilnc-comment-or-uncomment-lines)))
#+end_src
* User Interface

** Nano Theme

#+begin_src emacs-lisp
(use-package memoize)
(use-package nano-theme
  :ensure (nano-theme :host github :repo "aaronjensen/nano-theme" :protocol ssh)
  :config
  :init
  ;; Vertical window divider
  (setq window-divider-default-right-width 1)
  (setq window-divider-default-bottom-width 1)
  (setq window-divider-default-places t)
  (window-divider-mode 1)

  ;; No ugly button for checkboxes
  (setq widget-image-enable nil)

  (setq
   nano-window-divider-show t

   nano-light-background "#FFFFFF"          ;; While
   nano-light-highlight "#F9FAFB"           ;; Cool Gray 50
   nano-light-background-alt "#F3F4F6"      ;; Cool Gray 100
   nano-light-subtle "#E5E7EB"              ;; Cool Gray 200
   nano-light-fringe "#D1D5DB"              ;; Cool Gray 300
   nano-light-cursor-alt "#9CA3AF"          ;; Cool Gray 400
   nano-light-faded "#6B7280"               ;; Cool Gray 600
   nano-light-bold "#374151"                ;; Cool Gray 700
   nano-light-foreground "#1F2937"          ;; Cool Gray 800
   nano-light-foreground-alt "#111827"      ;; Cool Gray 900
   nano-light-strong "#000000"              ;; Black
   nano-light-critical "#EA580C"            ;; Orange 600
   nano-light-salient "#5B21B6"             ;; Violet 800
   nano-light-selected-background "#BAE6FD" ;; Sky 200
   nano-light-popout "#0369A1"              ;; Sky 700
   )

  (load-theme 'nano t)

  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "SF Pro" :height 150 :weight normal))))
   '(vundo-default ((t (:family "Iosevka SS04"))))))
#+end_src

** Nano Modeline

#+begin_src emacs-lisp
(use-package nano-modeline
  :ensure (nano-modeline :host github :repo "rougier/nano-modeline")
  :demand t
  :init
  (setq-default mode-line-format nil)
  (add-hook 'after-change-major-mode-hook #'c/nano-modeline)

  :preface
  (defun c/nano-modeline ()
    "Set modeline accordingly"
    (cond ((derived-mode-p 'prog-mode)
           (c/nano-modeline-prog-mode))
          ((derived-mode-p 'vterm-mode))
          (t
           (c/nano-modeline-text-mode))))

  :config
  (require 'memoize)

  ;; This is copy/pasted from nano-modeline but has the truncation removed
  (defun nano-modeline--make (left right face-prefix)
    "Build a dynamic mode/header line made of LEFT and RIGHT part,
using the given FACE-PREFIX as the default."

    `(:eval
      (let* ((nano-modeline-base-face (nano-modeline--base-face ',face-prefix))
             (left (mapconcat
                    (lambda (element)
                      (if (stringp element)
                          (propertize element 'face nano-modeline-base-face)
                        (apply (car element) (cdr element))))
                    ',left))
             (right (mapconcat
                     (lambda (element)
                       (if (stringp element)
                           (propertize element 'face nano-modeline-base-face)
                         (apply (car element) (cdr element))))
                     ',right))
             (fringe (if fringes-outside-margins 0.0 -1.0)))
        (concat (propertize " "
                            'display `(space :align-to (+ left
                                                          (,fringe . left-fringe)
                                                          (0.0 . left-margin))))
                left
                (propertize " "
                            'face `(:inherit ,nano-modeline-base-face)
                            'display `(space :align-to (- right
                                                          (,fringe . right-fringe)
                                                          (0.0 . right-margin)
                                                          ,(length right))))
                right))))

  (defun c/nano-modeline-project-root ()
    "Return the current project name or nil."
    (when-let* ((project (project-current)))
      (project-root project)))

  (defun c/nano-modeline-project-name ()
    "Return the current project name or nil."
    (when-let* ((project-root (c/nano-modeline-project-root)))
      (file-name-nondirectory (directory-file-name project-root))))

  (defmemoize c/nano-modeline-project-relative-name (file-name max-width)
    (c/shorten-directory-path
     (if-let* ((project-root (c/nano-modeline-project-root)))
         (file-relative-name file-name project-root)
       file-name)
     max-width))

  (defun c/nano-modeline-buffer-file-name ()
    (when buffer-file-name
      (c/nano-modeline-project-relative-name
       (substring-no-properties buffer-file-name)
       (- (window-width) 20))))

  (defun c/nano-modeline-buffer-name (&optional name)
    (concat
     (propertize
      (or name
          (c/nano-modeline-buffer-file-name)
          (format-mode-line "%b"))
      'face (nano-modeline-face 'name))
     (propertize
      (if (and buffer-file-name
               (buffer-modified-p))
          (concat (propertize " " 'display '(space :width (3)))
                  (propertize "â¬¤" 'display '((raise 0.15) (height 0.4)))
                  (propertize " " 'display '(space :width (6))))
        (propertize " " 'display '(space :width (16))))
      'face (nano-modeline-face 'header))))

  (defvar c/nano-modeline-abbreviations
    '(("incorporation" . "inc")
      ("document" . "doc")
      ("documents" . "docs")
      ("generation" . "gen")))

  (defun c/nano-modeline-abbreviate (text)
    (with-temp-buffer
      (insert text)
      (goto-char (point-min))
      (while (re-search-forward "\\b\\w+\\b" nil t)
        (let* ((word (match-string 0))
               (abbr (assoc-default word c/nano-modeline-abbreviations)))
          (when abbr
            (replace-match abbr))))
      (buffer-string)))

  (defun c/nano-modeline-project (&rest args)
    "Current project"
    (propertize
     (let ((name (c/nano-modeline-project-name))
           (max-length 32))
       (if name
           (progn
             (when (> (length name) max-length)
               (setq name (c/nano-modeline-abbreviate name)))

             (when (> (length name) max-length)
               (setq name (concat
                           (substring name 0 (- max-length 1))
                           "â€¦")))

             (concat "[" name "]"))
         ""))
     'face (nano-modeline-face 'project)))

  (defun c/nano-modeline-window-dedicated ()
    (when (window-dedicated-p)
      (propertize "ðŸ–ˆ " 'face (nano-modeline-face 'secondary) 'display '(height 0.85))))

  (defun c/nano-modeline-prog-mode (&optional default)
    "Nano line for prog mode. Can be made DEFAULT mode."

    (funcall nano-modeline-position
             '((c/nano-modeline-window-dedicated)
               (c/nano-modeline-buffer-name)
               (c/nano-modeline-project))
             '((nano-modeline-cursor-position))
             default))

  (defun c/nano-modeline-text-mode (&optional default)
    "Nano line for text mode. Can be made DEFAULT mode."

    (funcall nano-modeline-position
             '((c/nano-modeline-window-dedicated)
               (c/nano-modeline-buffer-name)
               (c/nano-modeline-project))
             '((nano-modeline-cursor-position))
             default))

  (defface c/nano-modeline-name-active-face
    '((t :weight semibold
         :inherit (variable-pitch nano-modeline-active)))
    "Active name face.")
  (defface c/nano-modeline-name-inactive-face
    '((t :weight semibold
         :inherit (variable-pitch nano-faded nano-modeline-inactive)))
    "Inactive name face.")
  (defface c/nano-modeline-project-active-face
    '((t :height 0.8
         :inherit (variable-pitch nano-modeline-active)))
    "Active project face.")
  (defface c/nano-modeline-project-inactive-face
    '((t :height 0.8
         :inherit (variable-pitch nano-faded nano-modeline-inactive)))
    "Inactive project face.")
  (defface c/nano-modeline-secondary-face
    '((t :height 0.94
         :inherit (nano-faded)))
    "Secondary face.")

  (push '(name-active c/nano-modeline-name-active-face) nano-modeline-faces)
  (push '(name-inactive c/nano-modeline-name-inactive-face) nano-modeline-faces)
  (push '(project-active c/nano-modeline-project-active-face) nano-modeline-faces)
  (push '(project-inactive c/nano-modeline-project-inactive-face) nano-modeline-faces)
  (push '(secondary-active c/nano-modeline-secondary-face) nano-modeline-faces)
  (push '(secondary-inactive c/nano-modeline-secondary-face) nano-modeline-faces)

  (with-current-buffer "*Messages*"
    (c/nano-modeline)))
#+end_src

** Font Size

#+begin_src emacs-lisp
(use-feature emacs
  :bind (("s-=" . #'global-text-scale-adjust)
         ("s--" . #'global-text-scale-adjust)
         ("s-0" . #'global-text-scale-adjust)
         ("C-=" . #'text-scale-adjust)
         ("C--" . #'text-scale-adjust)
         ("C-0" . #'text-scale-adjust))

  :preface
  (defvar presentation-mode-font-size 21)
  (defun presentation-mode ()
    "Increase the font size for presentation."
    (interactive)
    (let* ((current-font-size (/ (face-attribute 'default :height) 10))
           (new-font-size
            (if (not (eq current-font-size presentation-mode-font-size))
                presentation-mode-font-size
              c/monospace-font-size)))
      (set-face-attribute 'default nil :height (* new-font-size 10))
      (set-face-attribute 'variable-pitch nil :height (* new-font-size 10))
      (redisplay 'force))))
#+end_src

** Tab Bar

#+begin_src emacs-lisp
(leader-key-set "t n" #'tab-new
                "t c" #'tab-close
                "t C" #'tab-close-other
                "t t" #'tab-switch
                "t r" #'tab-rename
                "t d" #'tab-window-detach
                "t TAB" #'tab-bar-switch-to-recent-tab
                "t <" #'tab-bar-move-tab-backward
                "t >" #'tab-move
                "t p" #'c/tab-switch-project
                "e e" #'c/tab-emacs-config
                "o a" #'c/tab-org-agenda
                "w u" #'tab-bar-history-back
                "w C-r" #'tab-bar-history-forward)

(use-feature tab-bar
  :after nano-theme
  :bind (("s-1" . #'tab-select)
         ("s-2" . #'tab-select)
         ("s-3" . #'tab-select)
         ("s-4" . #'tab-select)
         ("s-5" . #'tab-select)
         ("s-6" . #'tab-select)
         ("s-7" . #'tab-select)
         ("s-8" . #'tab-select)
         ("s-9" . #'tab-select)
         ("s-w" . #'tab-close)
         ("s-T" . #'tab-undo)
         ("s-}" . #'tab-next)
         ("s-{" . #'tab-previous)
         ("s-t" . #'tab-new)

         :map tab-bar-map
         ("<wheel-up>" . #'ignore)
         ("<wheel-down>" . #'ignore)

         :repeat-map tab-bar-move-repeat-map
         ("<" . #'tab-bar-move-tab-backward)
         (">" . #'tab-move)

         :repeat-map tab-bar-history-repeat-map
         ("u" . #'tab-bar-history-back)
         ("C-r" . #'tab-bar-history-forward))

  :preface
  (defun c/tab-switch-project (project-to-switch)
    "Switch to project tab and find project file.
Only if the switched to buffer is not of that project."
    (interactive (list (project-prompt-project-dir)))

    (let* ((project-name (c/project-name project-to-switch))
           (tab-name project-name)
           new-tab
           (tab-bar-new-tab-choice
            (lambda ()
              (setq new-tab t)
              (if (string= project-name (c/project-name))
                  (current-buffer)
                (let ((default-directory project-to-switch))
                  (project-find-file))))))
      (tab-bar-switch-to-tab tab-name)

      ;; When switching, open a project file if the current-buffer is not one
      (unless new-tab
        (funcall tab-bar-new-tab-choice))))

  (defun c/tab-emacs-config ()
    "Edit the `dotfile', in the current window."
    (interactive)
    (let ((tab-bar-new-tab-choice "*scratch*"))
      (tab-bar-switch-to-tab ".emacs.d")
      (find-file-existing (concat user-emacs-directory "config.org"))))


  :config
  (setq tab-bar-show t
        tab-bar-new-tab-choice t
        tab-bar-new-button nil
        tab-bar-close-button-show nil
        tab-bar-new-tab-to 'rightmost
        tab-bar-tab-name-function #'c/name-tab-by-project-or-default
        ;; If this is the default (t) the name format function below causes
        ;; emacs to hang on boot since commit ca3763af5cc2758ec71700029558e6ecc4379ea9
        tab-bar-auto-width nil)

  (tab-bar-history-mode)

  (defun c/name-tab-by-project-or-default ()
    "Return project name if in a project, or default tab-bar name if not.
The default tab-bar name uses the buffer name."
    (or (c/project-name)
        (tab-bar-tab-name-current)))

  (defun c/tab-bar--tabs-recent (&optional tabs frame)
    "Ensure that the current tab is included."
    ;; Return the list of tabs sorted by recency.
    (let* ((tabs (or tabs (funcall tab-bar-tabs-function frame))))
      (seq-sort-by (lambda (tab) (or (alist-get 'time tab) 0)) #'>
                   tabs)))

  (advice-add #'tab-bar--tabs-recent :override #'c/tab-bar--tabs-recent))
#+end_src

*** Modern Tab Styling

#+begin_src emacs-lisp
(use-package modern-tab-bar
  :after tab-bar
  :ensure (modern-tab-bar :host github :repo "aaronjensen/emacs-modern-tab-bar" :protocol ssh)
  :init
  (modern-tab-bar-mode))
#+end_src

** Full Screen

#+begin_src emacs-lisp
(setq toggle-frame-maximized t)
#+end_src

** Completion Menu (Vertico)

#+begin_src emacs-lisp
(use-package vertico
  :config
  (vertico-mode))
#+end_src

** Completion At Point

*** Ripgrep Completion-at-Point Function

#+begin_src emacs-lisp
(use-package ripgrep-capf
  :after cape
  :ensure (:host github :repo "aaronjensen/ripgrep-capf" :protocol ssh)
  :init
  (defalias 'capf-dabbrev-ripgrep (cape-capf-super #'cape-dabbrev #'ripgrep-capf)))
#+end_src

*** Additional Completion-at-Point Functions (cape)

#+begin_src emacs-lisp
(use-package cape
  :init
  (add-hook 'completion-at-point-functions #'cape-elisp-block)
  :config
  (setq cape-dabbrev-check-other-buffers nil))
#+end_src

*** Inline Completion

#+begin_src emacs-lisp
(use-package corfu
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
        ("C-n" . nil)
        ("C-p" . nil)
        ([remap next-line] . nil)
        ([remap previous-line] . nil)
        ([remap move-end-of-line] . nil)
        ([remap move-beginning-of-line] . nil)
        ("\r" . nil)
        ("<escape>" . corfu-quit))
  :init
  ;; Tab will trigger completion if it does not need to indent
  (setq tab-always-indent 'complete)
  ;; Disable text-mode ispell completion at point function
  (setq text-mode-ispell-word-completion nil)
  ;; TAB-and-Go customizations
  (setq
   ;; Enable cycling for `corfu-next/previous'
   corfu-cycle t
   corfu-preselect 'prompt)
  ;; Auto completion
  (setq
   corfu-auto t
   corfu-auto-prefix 2
   corfu-auto-delay 0.1)
  :config
  (corfu-history-mode))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  :bind (("C-x b" . consult-buffer)))
#+end_src

** Completion Style (Orderless)

The orderless completion style allows typing parts of what is being matched,
separated by spaces. For example, "som thi" will match "this-is-some-thing".

#+begin_src emacs-lisp
(use-package orderless
  :init
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Minibuffer Annotations (Marginalia)

#+begin_src emacs-lisp
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  :bind (:map minibuffer-local-map
              ("M-A" . marginalia-cycle))

  :config
  (marginalia-mode))
#+end_src

** Miniframe

#+begin_src emacs-lisp
(use-package mini-frame
  :config
  (custom-set-variables
   '(mini-frame-show-parameters
     '((top . 0.4)
       (width . 0.8)
       (left . 0.5)
       (height . 5)
       (left-fringe . 12)
       (right-fringe . 12)
                                        ;(top-fringe . 12)
                                        ;(bottom-fringe .12)
       (child-frame-border-width . 1)
       (internal-border-width . 1)))
   '(mini-frame-color-shift-step 7))
  (setq mini-frame-internal-border-color "black")
  :init
  (mini-frame-mode))
#+end_src

** Minibuffer Actions Rooted in Keybindings (Embark)

#+begin_src emacs-lisp
(use-package embark
  :bind (:map
         vertico-map
         ("C-c C-o" . #'embark-export)
         ("C-c C-c" . #'embark-act)
         ("C-c C-e" . #'c/embark-export-wgrep))
  :preface
  (defvar c/embark-export-wgrep nil)
  (defun c/embark-export-wgrep ()
    "Embark export then wgrep"
    (interactive)
    (setq c/embark-export-wgrep t)
    (command-execute #'embark-export)))

(use-package embark-consult
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  :config
  (declare-function wgrep-change-to-wgrep-mode "ext:wgrep")
  (defun c/embark-export-grep-wgrep (&rest _)
    "Start wgrep when indicated"
    (when c/embark-export-wgrep
      (setq c/embark-export-wgrep nil)
      (when (eq major-mode 'grep-mode)
        (wgrep-change-to-wgrep-mode))))
  (advice-add #'embark-consult-export-grep :after #'c/embark-export-grep-wgrep))
#+end_src

* Text Editing

** Delete Trailing Whitespace

#+begin_src emacs-lisp
(use-package ws-butler
  :config (ws-butler-global-mode))
#+end_src

** Spell Checking (Flyspell)

#+begin_src emacs-lisp
(use-feature flyspell
  :hook ((org-mode git-commit-mode markdown-mode) . flyspell-mode)

  :config
  (setq flyspell-issue-message-flag nil
        flyspell-issue-welcome-flag nil))
#+end_src

** Editing Search Results (wgrep)

#+begin_src emacs-lisp
(use-package wgrep
  :config
  (setq wgrep-auto-save-buffer t))
#+end_src

* Projects

** Tree View (Treemacs)

#+begin_src emacs-lisp
(use-package treemacs
  :bind ("s-b" . #'treemacs)
  :config
  (treemacs-follow-mode))
#+end_src

** Workspaces (Tabspaces)

#+begin_src emacs-lisp
(use-package tabspaces
  :after consult

  :init
  (setq tabspaces-session-file (no-littering-expand-var-file-name "tabsession.el")
        tabspaces-project-switch-commands #'project-find-file)

  (tabspaces-mode)

  :config
  (consult-customize consult--source-buffer :hidden t :default nil)

  ;; set consult-workspace buffer list
  (defvar consult--source-workspace
    (list :name "Workspace Buffers"
          :narrow ?w
          :history 'buffer-name-history
          :category 'buffer
          :state #'consult--buffer-state
          :default t
          :items (lambda () (consult--buffer-query
                             :predicate #'tabspaces--local-buffer-p
                             :sort 'visibility
                             :as #'buffer-name)))

    "Set workspace buffer list for consult-buffer.")
  (add-to-list 'consult-buffer-sources 'consult--source-workspace))
#+end_src

* File Types

** Defaults

*** Indentation

Two space indentation by default.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2
              smie-indent-basic 2)
#+end_src

** Shell

#+begin_src emacs-lisp
(use-feature shell
  :config
  (setq sh-basic-offset 2))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :config

  (add-hook 'markdown-mode-hook #'visual-line-mode)
  (add-hook 'markdown-mode-hook #'visual-wrap-prefix-mode)

  (setq markdown-list-indent-width 2))
#+end_src

** Ruby

#+begin_src emacs-lisp
(use-feature ruby-mode
  :hook (ruby-mode . corfu-mode)
  :capf capf-dabbrev-ripgrep
  :config
  (setq ruby-block-indent nil
        ruby-method-call-indent nil
        ruby-method-params-indent nil
        ruby-after-operator-indent nil
        ruby-bracketed-args-indent nil))
#+end_src

* Version Control

** Magit

#+begin_src emacs-lisp
(use-package magit)
#+end_src

Install latest version of transient, as the version included in Emacs is not recent enough.

#+begin_src emacs-lisp
(use-package transient)
#+end_src

Start git commit in insert mode

#+begin_src emacs-lisp
(use-package git-commit
  :after magit
  :config
  (add-hook 'git-commit-setup-hook
            (defun +vc-start-in-insert-state-maybe-h ()
              "Start git-commit-mode in insert state if in a blank commit message, otherwise in default state."
              (when (and (bound-and-true-p evil-local-mode)
                         (not (evil-emacs-state-p))
                         (bobp) (eolp))
                (evil-insert-state)))))
#+end_src

* Assistance

** Which Key

#+begin_src emacs-lisp
(use-feature which-key
  :config
  (which-key-mode))
#+end_src

** Helpful

#+begin_src emacs-lisp
  (use-package helpful
    :hook (helpful-mode . visual-line-mode)
    :bind (
           ;; Remap standard commands
           ([remap describe-function] . #'helpful-callable)
           ([remap describe-command] . #'helpful-command)
           ([remap describe-variable] . #'helpful-variable)
           ([remap describe-symbol] . #'helpful-symbol)
           ([remap describe-key] . #'helpful-key)))
#+end_src

* Undo

** Vundo

#+begin_src emacs-lisp
(use-package vundo)
#+end_src

** Undo Fu Session

#+begin_src emacs-lisp
(use-package undo-fu-session
  :config
  (setq undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
  (undo-fu-session-global-mode))
#+end_src

* Major Modes

** Org

#+begin_src emacs-lisp
(use-feature org-mode
  :hook (org-mode . corfu-mode)
  :init
  (setq org-edit-src-content-indentation 0))
#+end_src

* Minor Modes

** Parens

#+begin_src emacs-lisp
(use-package smartparens
  :config (smartparens-global-mode))
#+end_src

** Line Numbers

#+begin_src emacs-lisp
(setq display-line-numbers-type 't)  ; Options: 'relative, 't (absolute), 'visual
(setq display-line-numbers-width 3)         ; Adjust width of line number display
(setq display-line-numbers-grow-only t)     ; Prevent width from shrinking
#+end_src

* Terminal

** Terminal Emulator (vterm)

#+begin_src emacs-lisp
(use-package vterm
  :config
  (setq vterm-always-compile-module t
        ;; Defaults to 0.1. Decreasing this greatly impacts performance of
        ;; rendering large batches of text.
        vterm-timer-delay 0.06))
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package vterm-toggle
  :bind (("s-i" . vterm-toggle)))
#+end_src

* Startup Time

#+begin_src emacs-lisp
(add-hook 'after-init-hook
          (lambda ()
            (let ((inhibit-message t))
              (message "Emacs init time: %s" (emacs-init-time)))))
#+end_src
